[{"content":"学习yolov11的一些基本概念，和一些基础操作内容的作用\n配置文件 在yolov11下载的工具包中，\u0026ldquo;ultralytics-main\\ultralytics\\cfg\\models\\11\\yolo11.yaml\u0026rdquo;，该文件中包括了yolov11的配置文件\n主干网络 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # YOLO11n backbone backbone: # [from, repeats, module, args] - [-1, 1, Conv, [64, 3, 2]] # 0-P1/2 - [-1, 1, Conv, [128, 3, 2]] # 1-P2/4 - [-1, 2, C3k2, [256, False, 0.25]] - [-1, 1, Conv, [256, 3, 2]] # 3-P3/8 - [-1, 2, C3k2, [512, False, 0.25]] - [-1, 1, Conv, [512, 3, 2]] # 5-P4/16 - [-1, 2, C3k2, [512, True]] - [-1, 1, Conv, [1024, 3, 2]] # 7-P5/32 - [-1, 2, C3k2, [1024, True]] - [-1, 1, SPPF, [1024, 5]] # 9 - [-1, 2, C2PSA, [1024]] # 10 [-1, 2, C3k2, [256, False, 0.25]] 这四个参数的含义：\n-1：表示输入来源 -1 表示使用上一层的输出作为输入 如果是其他数字(如6)，则表示使用第6层的输出作为输入 这种设计允许网络创建跳跃连接 2：表示重复次数 这个模块会重复执行2次 每次执行都会使用前一次的输出作为输入 增加网络深度和特征提取能力 C3k2：模块名称 表示使用C3k2模块（一种改进的CSP模块） [256, False, 0.25]：模块参数 可见主干网络包括以下关键组件： 1.初始卷积层 2.特征提取层\n1.初始卷积层 1 2 - [-1, 1, Conv, [64, 3, 2]] # 0-P1/2 - [-1, 1, Conv, [128, 3, 2]] # 1-P2/4 第一层卷积：Conv, [64, 3, 2] 输入：原始图像 (3通道) 输出：64通道特征图 卷积核：3×3 步长：2\n第二层卷积：Conv, [128, 3, 2] 输入：64通道特征图 输出：128通道特征图 卷积核：3×3 步长：2\n步长2实现降采样 通道数增加扩展特征维度 通道数增加的意义 每个通道代表一种特征模式 更多通道 = 可以学习更多种类的特征 类比：用64/128支画笔来画画，画笔越多，可以表达的细节越丰富\n主要作用 1.降采样\n每层步长为2，两层共降采样4倍 640×640 → 320×320 → 160×160 减少后续计算量 2.特征提取 提取基础的视觉特征（如边缘、纹理等） 通道数增加：3 → 64 → 128 增加特征表达能力 3.信息压缩 压缩空间维度 扩展通道维度 为后续深层特征提取做准备 2.特征提取层 1 2 3 4 5 6 7 8 9 - [-1, 2, C3k2, [256, False, 0.25]] - [-1, 1, Conv, [256, 3, 2]] # 3-P3/8 - [-1, 2, C3k2, [512, False, 0.25]] - [-1, 1, Conv, [512, 3, 2]] # 5-P4/16 - [-1, 2, C3k2, [512, True]] - [-1, 1, Conv, [1024, 3, 2]] # 7-P5/32 - [-1, 2, C3k2, [1024, True]] - [-1, 1, SPPF, [1024, 5]] # 9 - [-1, 2, C2PSA, [1024]] # 10 包含三个模块 1. C3k2 模块\n1.参数说明：\n[256, False, 0.25]： 256：输出通道数 False：是否使用 shortcut 连接 0.25：通道压缩比例 2.工作原理： 将输入特征分成两部分 一部分直接通过 另一部分经过多个卷积层处理 最后合并两部分特征 3.优势： 减少计算量 保持梯度流动 增强特征提取能力 Shortcut 连接 shortcut 连接是一种网络设计技巧，主要有以下特点： 1.基本原理\n在网络中创建一条捷径 让信息可以跳过某些层直接传递 类似于高速公路的快车道 2.作用 2.1 解决梯度消失问题\n深层网络训练困难 shortcut 提供梯度反向传播的快速通道 帮助深层网络也能有效训练 2.2 保留原始信息 让网络可以直接访问浅层特征 避免信息在传递过程中损失 提高特征利用效率 提升模型性能 加快收敛速度 提高特征提取能力 改善最终检测效果 2. SPPF 模块\n1.参数说明：\n[1024, 5]： 1024：输出通道数 5：最大池化核大小 2.工作原理： 输入特征先经过 1×1 卷积降维 连续进行最大池化，得到不同尺度特征 将所有特征拼接 最后用 1×1 卷积整合 3.优势： 获取多尺度上下文信息 比传统 SPP 更快 增大感受野 3. C2PSA 模块\n1.参数说明：\n[1024]：输出通道数 2.工作原理： 2.1 空间注意力计算： 生成空间注意力图 突出重要区域 抑制无关区域 2.2 特征增强 原始特征与注意力图相乘 增强重要特征 抑制噪声特征 3.优势： 自适应特征增强 提高特征表达能力 改善检测性能 ","date":"2024-11-29T15:00:00+08:00","permalink":"https://0Hzc.github.io/p/yolo%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/","title":"yolo学习记录1"},{"content":"记录给云服务器设置本地局域网代理\n大致概括 通过ssh建立本地代理服务器与云服务器的连接，开启本地代理，关闭本地代理服务器防火墙，关闭云服务器防火墙，设置云服务器代理\n1.建立ssh连接 将本地代理端口映射至云服务器的ssh连接端口，如22，10022\n1 2 3 #打开代理终端，进行ssh配置连接 #以本地代理端口为7897为例 ssh -i C:\\Users\\H\\.ssh\\id_rsa -R 7897:localhost:7897 username@ip -p 10022 确保ssh服务器连接成功 注解：其中-i 后面设置的参数是密钥对的地址，@前面是云服务器的用户名，@后面是云服务器的公网ip，-p 后面设置的是云服务器的ssh连接端口\n2.开启本地代理 启动clash或其他代理工具，开启局域网连接，选择转发端口为7897\n3.关闭本地代理服务器防火墙 4.设置云服务器的代理 1 2 3 4 5 6 7 8 9 10 #设置http代理 export http_proxy=http://localhost:7897 #设置https代理 export https_proxy=http://localhost:7897 #查看云服务代理 env | grep -i proxy #测试代理是否成功 curl -i www.google.com 5.取消代理 1 2 export http_proxy=\u0026#34;\u0026#34; export https_proxy=\u0026#34;\u0026#34; ","date":"2024-11-22T15:00:00+08:00","permalink":"https://0Hzc.github.io/p/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/","title":"云服务器代理设置"},{"content":"记录并总结python中与终端的交互处理、参数传递等\n实现两种终端处理方式，一种为命令行参数，一种为终端输入 终端输入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #导入模块 import sys from colorama import Fore, Style ## 定义终端获取输入函数 def get_user_input(): print(f\u0026#34;{Fore.CYAN}请输入以下参数：{Style.RESET_ALL}\u0026#34;) # 获取输入数据路径 while True: input_path = input(f\u0026#34;{Fore.YELLOW}请输入.SAFE结尾的文件夹绝对路径：{Style.RESET_ALL}\u0026#34;).strip() if os.path.exists(input_path) and input_path.endswith(\u0026#39;.SAFE\u0026#39;): print(f\u0026#34;{Fore.GREEN}成功输入输入数据路径：{input_path}{Style.RESET_ALL}\u0026#34;) break else: print(f\u0026#34;{Fore.RED}错误：路径不存在或不是有效的.SAFE文件夹，请重新输入{Style.RESET_ALL}\u0026#34;) return input_path ## 调用函数 input_path = get_user_input() print(f\u0026#34;{Fore.MAGENTA}输入路径为：{input_path}{Style.RESET_ALL}\u0026#34;) 注：\n命令行参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #导入模块 import argparse ## 定义参数设置函数 def parse_arguments(): # 设置参数解析器 parser = argparse.ArgumentParser(description=\u0026#39;护花米草遥感识别处理程序\u0026#39;) ## 添加必填参数与非必填参数 #必需的参数 parser.add_argument(\u0026#39;-i\u0026#39;, \u0026#39;--input\u0026#39;, required=True, help=\u0026#39;输入数据文件夹路径（包含nc文件）\u0026#39;) parser.add_argument(\u0026#39;-w\u0026#39;, \u0026#39;--word\u0026#39;, required=True, help=\u0026#39;Word模板文件路径（.docx文件）\u0026#39;) parser.add_argument(\u0026#39;-o\u0026#39;, \u0026#39;--output\u0026#39;, required=True, help=\u0026#39;输出结果保存路径\u0026#39;) #非必填，带默认值的参数 parser.add_argument(\u0026#39;--threshold\u0026#39;, type=float, default=0.5, help=\u0026#39;阈值\u0026#39;) # 解析参数 args = parser.parse_args() #返回参数 return args ## 调用函数 def main(): args = parse_arguments() print(f\u0026#34;{Fore.MAGENTA}输入路径为：{args.input_path}{Style.RESET_ALL}\u0026#34;) 注：\n","date":"2024-11-21T15:00:00+08:00","permalink":"https://0Hzc.github.io/p/python%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/","title":"python学习记录1"},{"content":"本文记录如何使用yjs+quill协同编辑器进行二次部署,使用已经搭建过的yjsdemo实现快速部署 用于服务器更新资源，需要二次部署时使用\n步骤1： 从github仓库中下载源码\n步骤2： 安装npm、nginx反向代理\n步骤3： 在工程目录下npm install\n步骤4： 编辑nginx配置文件,以petherfish.cn为例\n1 sudo nano /etc/nginx/sites-available/petherfish.cn 配置文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 server { listen 80; listen [::]:80; server_name petherfish.cn; # 编辑器的反向代理配置 location /edit { proxy_pass http://localhost:5173; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;upgrade\u0026#34;; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; # WebSocket 支持 proxy_read_timeout 86400; } # WebSocket 服务器的反向代理配置 location /ws { proxy_pass http://localhost:1234; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;upgrade\u0026#34;; proxy_set_header Host $host; proxy_read_timeout 86400; } # 用于处理其他请求 location / { root /usr/share/nginx/html; index index.html index.htm; try_files $uri $uri/ =404; } # 日志配置 access_log /var/log/nginx/petherfish.cn.access.log; error_log /var/log/nginx/petherfish.cn.error.log; } 重启nginx\n1 sudo systemctl restart nginx 步骤5： 本地测试\n1 npm start 1 npm run dev 无报错后访问petherfish.cn/edit/,测试是否可以正常访问\n步骤6： 编写vite.config.js文件，系统服务文件 编写webserver.py文件，系统服务文件\n","date":"2024-11-20T15:00:00+08:00","permalink":"https://0Hzc.github.io/p/%E5%A6%82%E4%BD%95%E5%86%8D%E6%AC%A1%E9%83%A8%E7%BD%B2yjs-quill%E5%8D%8F%E5%90%8C%E7%BC%96%E8%BE%91%E5%99%A8/","title":"如何再次部署yjs+quill协同编辑器"},{"content":"学习开发python项目 附录内容为python的相关语法和库的介绍 主体内容为python项目开发流程和框架结构\nstep1 创建项目目录 在项目目录下创建以下文件：\nREADME.md modules/init.py、modules/readers/init.py utils/init.py main.py step2 编写代码 编写 init.py文件 从模块中的readers的__init__.py文件为例，开始编写代码\n1 2 3 4 5 6 7 #定义一个文件类型的枚举，用于标识不同的文件类型 from enum import Enum class FileType(Enum): H5 = \u0026#34;h5\u0026#34; NC = \u0026#34;nc\u0026#34; RULE = \u0026#34;rule\u0026#34; 编写公共模块 编写基础功能模块 附录 文件说明 关于 utils 文件夹 utils 是 \u0026ldquo;utilities\u0026rdquo;（实用工具）的缩写 这个文件夹用来存放一些通用的工具函数或类 比如文件处理、日志记录、时间格式转换等公共功能 这些功能会被多个其他模块重复使用，所以单独放在一起便于维护\n关于 readers 文件夹 这是运用了模块化编程的思想 readers 文件夹专门用来存放所有与文件读取相关的代码 这样的组织方式有几个好处： 代码结构清晰 相关功能集中管理 便于维护和扩展\n关于 init.py 文件 在 Python 中，任何包含 init.py 文件的文件夹都会被视为一个 Python 包 这个文件可以是空的，仅用来标识这个文件夹是一个 Python 包 它允许你使用 import 语句导入这个文件夹中的模块 例如：\n1 2 # 如果没有 __init__.py，这样的导入是不可能的 from modules.readers import xxx 思想流程 检验系统其中包括：文件转换 → 而文件转换包括其中：文件读取→ 而文件读取时，如果有新的文件类型需要读取，那么就可以制作一个文件读取器 ，后续需要新建新的文件读取，只需要维护这个文件读取器即可 → 文件读取器要能够自动实现类型添加 → 可以在readers文件夹中的 init.py文件中定义一个枚举类，在readers文件夹中创建一个reader_factory.py文件,在这个文件中定义一个readerfactory的类，在reader_factory中创建创建读取器对象的静态方法,之后只要添加新的类型处理，只需要在__init__.py文件中添加新的类型，在reader_factory.py文件中添加新的类型匹配处理即可\n思想流程图：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 检验系统 └── 文件转换 └── 文件读取 ├── readers/__init__.py (定义文件类型枚举) │ └── class FileType(Enum): │ H5 = \u0026#34;h5\u0026#34; │ NC = \u0026#34;nc\u0026#34; │ RULE = \u0026#34;rule\u0026#34; │ # 未来可以在这里添加新类型 │ NEW_TYPE = \u0026#34;new\u0026#34; ← 步骤1：添加新类型 │ ├── readers/reader_factory.py │ └── class ReaderFactory: │ └── create_reader(): │ readers = { │ FileType.H5: H5Reader, │ FileType.NC: NCReader, │ FileType.RULE: RuleReader, │ FileType.NEW_TYPE: NewReader ← 步骤2：添加对应的处理器 │ } │ └── readers/new_reader.py ← 步骤3：实现新的读取器 └── class NewReader(BaseReader): └── def _read(self): # 实现具体的读取逻辑 os库 介绍 os (Operating System) 库是 Python 的标准库之一，提供了与操作系统交互的各种功能，让我们可以使用 Python 来执行操作系统级别的操作，比如：文件和目录操作、进程管理、环境变量操作、路径操作等\n常用方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ##路径操作 (os.path) # 检查文件或目录是否存在 os.path.exists(\u0026#34;file.txt\u0026#34;) # 返回 True 或 False # 获取文件名和扩展名 os.path.splitext(\u0026#34;file.txt\u0026#34;) # 返回 (\u0026#39;file\u0026#39;, \u0026#39;.txt\u0026#39;) # 拼接路径 os.path.join(\u0026#34;dir\u0026#34;, \u0026#34;file.txt\u0026#34;) # 返回 \u0026#34;dir/file.txt\u0026#34; (Linux) 或 \u0026#34;dir\\file.txt\u0026#34; (Windows) # 获取绝对路径 os.path.abspath(\u0026#34;file.txt\u0026#34;) # 判断是否为目录 os.path.isdir(\u0026#34;dirname\u0026#34;) # 判断是否为文件 os.path.isfile(\u0026#34;file.txt\u0026#34;) ##目录操作 # 获取当前工作目录 os.getcwd() # 改变当前工作目录 os.chdir(\u0026#34;path/to/dir\u0026#34;) # 列出目录内容 os.listdir(\u0026#34;dirname\u0026#34;) # 创建目录 os.mkdir(\u0026#34;dirname\u0026#34;) # 创建单个目录 os.makedirs(\u0026#34;a/b/c\u0026#34;) # 创建多级目录 ##文件操作 # 重命名文件或目录 os.rename(\u0026#34;old.txt\u0026#34;, \u0026#34;new.txt\u0026#34;) # 删除文件 os.remove(\u0026#34;file.txt\u0026#34;) # 删除空目录 os.rmdir(\u0026#34;dirname\u0026#34;) ##系统相关 # 获取环境变量 os.getenv(\u0026#34;PATH\u0026#34;) # 获取系统名称 os.name # \u0026#39;nt\u0026#39; (Windows) 或 \u0026#39;posix\u0026#39; (Linux/Unix) @staticmethod 装饰器 @staticmethod 装饰器用于定义一个静态方法，静态方法不需要访问类的实例属性，也不需要访问类的实例方法，它只是一些与类相关的工具函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Calculator: # 1. 普通实例方法（需要实例化才能调用） def add(self, a, b): return a + b # 2. 静态方法（不需要实例化就能调用） @staticmethod def subtract(a, b): return a - b # 使用实例方法 calc = Calculator() result1 = calc.add(1, 2) # 需要先创建实例 # 使用静态方法 result2 = Calculator.subtract(5, 3) # 直接通过类名调用 all 变量 all 变量用于定义模块的公共接口，它是一个列表，列出了模块中所有可以被外部导入的变量、函数或类\n1 __all__ = [\u0026#39;check_file_exists\u0026#39;, \u0026#39;get_file_extension\u0026#39;] ","date":"2024-11-09T15:00:00+08:00","permalink":"https://0Hzc.github.io/p/%E5%AD%A6%E4%B9%A0python%E9%A1%B9%E7%9B%AE/","title":"学习python项目"},{"content":"本文主要记录如何配置yolov11所需的anaconda环境以及下载并运行初始模型， 其中关于如何下载anaconda，配置conda至系统环境变量以及如何使用pycharm IDE进行选择conda环境见本文末尾的参考链接\n如何配置环境，并下载初始模型进行测试 conda基础命令 1 2 3 4 5 6 7 8 #查看当前存在哪些conda虚拟环境 conda env list #新建conda虚拟环境 conda create -n yolov11 python=3.10 #yolov11可随意更改,意义为创建的虚拟环境的名字 #激活conda虚拟环境/选择某个环境作为编译环境 conda activate yolov11 #此处的yolov11则为新建时创建的虚拟环境名字 步骤1：GPU安装相关驱动 参考文章尾部链接安装cuda、cudnn\n步骤2：配置虚拟环境 1 2 3 4 5 6 7 8 #查看当前环境存在哪些包 pip list #安装pytorch框架 pip install torch==2.0.0+cu118 torchvision==0.15.1+cu118 --extra-index-url https://download.pytorch.org/whl/cu118 #安装yolo命令包 pip install ultralytics 步骤3：下载模型、预训练权重 访问地址：https://github.com/ultralytics/ultralytics/（yolo的github仓库） 下载使用COCO数据集训练的得到的预训练权重文件、在仓库的Readme的model下的Detection (COCO)部分\nModel YOLO11n YOLO11s YOLO11m YOLO11l YOLO11x 在仓库的realse处下载模型压缩包\n步骤4：使用模型进行测试 1.将在realse下载的模型压缩包解压，并在IDE中打开，让终端在该目录下即可 2.将下载的预训练权重放置该目录下 3.随意准备一张测试图放置该目录下，准备用作目标检测\n1 yolo predict model=yolo11n.pt source=\u0026#39;cat.jpg\u0026#39; #yolo11n.pt修改为下载的预训练权重，cat.jpg修改为准备的图片名和格式 参考链接 https://blog.csdn.net/qq_67105081/article/details/143270109?spm=1001.2014.3001.5502\n","date":"2024-11-08T15:00:00+08:00","permalink":"https://0Hzc.github.io/p/%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8yolov11%E8%BF%9B%E8%A1%8C%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/","title":"初次使用yolov11进行目标检测"},{"content":"本文记录如何使用github的两个仓库进行部署hugo生成的静态html博客\n流程 步骤1： 在github上建立一个私有库，用于存放hugo的源代码（后续记录如何本地安装并调试hugo进行网页效果展示）\n步骤2： 再建立另一个仓库：0hzc.github.io，此仓库命名必须命名为xxx.github.io，xxx为你的github用户名\n步骤3： 在本地调试完hugo的网页确定无误后，在目录下新建.github文件夹，此文件夹与hugo new site 的文件夹同级,再在.github文件夹下新建一个名为workflows的文件夹\n步骤4： 在.github/workflows文件夹下新建xxx.yml文件，xxx随意命名，此文件为githubwebpages的自动部署文件，内容可填写为如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 name: github pages # 名字自取 on: push: branches: - main # 这里的意思是当 main分支发生push的时候，运行下面的jobs，这里先改为github-actions jobs: deploy: # 任务名自取 runs-on: ubuntu-latest\t# 在什么环境运行任务 steps: - uses: actions/checkout@v2\t# 引用actions/checkout这个action，与所在的github仓库同名 with: submodules: true # Fetch Hugo themes (true OR recursive) 获取submodule主题 fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo\t# 步骤名自取 uses: peaceiris/actions-hugo@v2\t# hugo官方提供的action，用于在任务环境中获取hugo with: hugo-version: \u0026#39;latest\u0026#39;\t# 获取最新版本的hugo extended: true - name: Build run: hugo --minify\t# 使用hugo构建静态网页 - name: Deploy uses: peaceiris/actions-gh-pages@v3\t# 一个自动发布github pages的action with: # github_token: ${{ secrets.GITHUB_TOKEN }} 该项适用于发布到源码相同repo的情况，不能用于发布到其他repo external_repository: 0Hzc/0Hzc.github.io\t# 发布到哪个repo personal_token: ${{ secrets.hzcblog }}\t# 发布到其他repo需要提供上面生成的personal access token publish_dir: ./public\t# 注意这里指的是要发布哪个文件夹的内容，而不是指发布到目的仓库的什么位置，因为hugo默认生成静态网页到public文件夹，所以这里发布public文件夹里的内容 publish_branch: main\t# 发布到哪个branch 其中需要做修改的为“ external_repository: 0Hzc/0Hzc.github.io”需要将对应的部分改为步骤2的仓库名，“personal_token: ${{ secrets.hzcblog }}”需要将对应的部分改为生成的personal access token\n步骤5： 使用git工具推送至步骤一建立的仓库即可\ngit的相关使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #将本地文件进行git git init #连接远程仓库 git remote add origin xxxxx #origin是远程仓库的别名，可以自定义，后续推送至仓库时需要用到这个别名，xxxx是远程仓库的url #检查连接的远程仓库，以及在本地的别名 git remote -v #将文件/修改的文件，添加至暂存区 git add . #也可以指定文件添加 将.改为具体文件路径 #可查看暂存区有哪些文件 git status #确定暂存区无误，确定提交 git commit -m \u0026#34;提交信息\u0026#34; #提交信息为自定义，可以写本次提交的说明 #将暂存区的文件提交至远程仓库 git push origin main #origin是远程仓库的别名，main是远程仓库的分支（branch），也可以自定义 #删除本地与远程仓库的连接 git remote remove origin #origin是远程仓库在本地的别名 参考链接 https://krislinzhao.github.io/docs/create-a-wesite-using-github-pages-and-hugo/\n","date":"2024-11-07T15:00:00+08:00","permalink":"https://0Hzc.github.io/p/%E4%BD%BF%E7%94%A8github-hugo%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/","title":"使用github+hugo部署博客"},{"content":"this article is to record how to use hugo to build blog\nintroduction this server is running on github\u0026rsquo;s codespace . I\u0026rsquo;ll try to solve this problem that can\u0026rsquo;t open the website by access 0Hzc.github.io\n1.step1 get ready for the environment,to deploy this server need go , git ,and install hugo_extrended . Notice that hugo edition is hugo_extrended not the standard hugo : if use the standard hugo,you will can\u0026rsquo;t deploy other themes.\n2. step2 according to the docs from hugo\u0026rsquo;s official websites,use the following command:\n1 2 3 4 5 hugo new site quickstart //dirname is the directory for storing the project cd quickstart git submodule add https://xxxxxxx.git themes/xxx. //xxxxxxx is the url for the themes which you choose,xxx is the name of themes echo \u0026#34;theme = \u0026#39;xxx\u0026#39;\u0026#34; \u0026gt;\u0026gt; hugo.toml. // this command is add \u0026#34;theme = \u0026#39;xxx\u0026#39;\u0026#34; into the hugo.toml hugo server ","date":"2024-11-05T15:00:00+08:00","permalink":"https://0Hzc.github.io/p/how-to-deploy-blog-system-by-hugo/","title":"How to deploy blog system by hugo"}]